---
import type { ImageMetadata } from "astro";
import { Image } from "astro:assets";

/**
 * Migration to optimized images:
 * - New flow: import images statically from `src/assets/images` (Astro generates metadata and optimizes).
 * (Legacy removed) Only assets.
 */

type ImgInput = string | ImageMetadata;
interface Props {
  /** Can be ImageMetadata (static import) or a '/images/...' path. */
  src: ImgInput;
  /** Dark variant (optional). */
  darkSrc?: ImgInput;
  alt: string;
  /** Optional if ImageMetadata is passed (inferred). */
  width?: number;
  /** Optional if ImageMetadata is passed (inferred). */
  height?: number;
  loading?: "eager" | "lazy";
  decoding?: "async" | "auto" | "sync";
  format?: "auto" | "avif" | "jpeg" | "png" | "svg" | "webp";
  class?: string;
  style?: any;
  fetchpriority?: "high" | "low" | "auto";
  aboveTheFold?: boolean;
}

let {
  src,
  darkSrc,
  alt,
  width,
  height,
  loading,
  decoding,
  class: className,
  format,
  style,
  fetchpriority,
  aboveTheFold,
}: Props = Astro.props;

if (aboveTheFold) {
  loading = loading || "eager";
  fetchpriority = fetchpriority || "high";
}
// If NOT above the fold, force lazy defaults to improve performance.
if (!aboveTheFold) {
  loading = loading || "lazy";
  fetchpriority = fetchpriority || "low";
  decoding = decoding || "async";
}

// Single glob for assets
const assetImages = import.meta.glob<{
  default: ImageMetadata;
}>("/src/assets/images/**/*.{jpeg,jpg,png,gif,webp,svg}", { eager: true });

interface ResolvedImage {
  meta: ImageMetadata;
}

const normalizePath = (p: string) => {
  // remove common prefixes
  return p
    .replace(/^https?:\/\/[^/]+/, "")
    .replace(/^\/public/, "")
    .replace(/^\/*/, "/");
};

const resolve = (input?: ImgInput): ResolvedImage | undefined => {
  if (!input) return undefined;
  if (typeof input !== "string") return { meta: input };
  const rel = normalizePath(input);
  const clean = rel.startsWith("/images/") ? rel : `/images${rel}`;
  const assetEntry = Object.entries(assetImages).find(([fullPath]) =>
    fullPath.endsWith(clean),
  );
  if (assetEntry) return { meta: assetEntry[1].default };
  console.error(
    `\x1b[31m[ImageMod] Image not found in assets: ${input}.\x1b[0m`,
  );
  return undefined;
};

const lightResolved = resolve(src);
const darkResolved = resolve(darkSrc);

// Determine final dimensions (priority: explicit props > metadata)
const finalWidth = width || lightResolved?.meta?.width || undefined;
const finalHeight = height || lightResolved?.meta?.height || undefined;

// No JSX here to avoid parser errors; only calculated data.
---

{
  !darkResolved && lightResolved && (
    <Image
      src={lightResolved.meta}
      alt={alt}
      width={finalWidth}
      height={finalHeight}
      loading={loading}
      decoding={decoding}
      class={className}
      format={format}
      style={style}
      fetchpriority={fetchpriority}
    />
  )
}
{
  darkResolved && lightResolved && (
    <>
      <Image
        src={lightResolved.meta}
        alt={alt}
        width={finalWidth}
        height={finalHeight}
        loading={loading}
        decoding={decoding}
        class={`${className ?? ""} block dark:hidden`}
        format={format}
        style={style}
        fetchpriority={fetchpriority}
      />
      <Image
        src={darkResolved.meta}
        alt={alt}
        width={finalWidth}
        height={finalHeight}
        loading={loading}
        decoding={decoding}
        class={`${className ?? ""} hidden dark:block`}
        format={format}
        style={style}
        fetchpriority={fetchpriority}
      />
    </>
  )
}
